- Promise handlers .then/.catch/.finally sẽ luôn là asynchronous.
- Kể cả khi Promise được resolved ngay lập tức thì code ở line bên dưới .then/.catch/.finally vẫn sẽ thực thi trước khi những handlers thực thi.

	let promise = Promise.resolve();

	promise.then(() => alert("promise done!"));

	alert("code finished"); // this alert shows first
	
** Microtasks queue :
- Asynchronous tasks cần được quản lý hợp lý.
- Do đó, ECMA standard chỉ định 1 internal queue PromiseJobs thường được gọi là 'microtask queue' (ES8 term);
- spec nêu :

	+ The queue là FIFO : tasks enqueued first được run first : những tasks xếp trước sẽ được chạy trước.
	+ Execution of task được khởi tạo chỉ khi nothing else is running.

- Nói cách khác khi promise sẵn sàng, các handlers sẽ được đẩy vào queue và chúng sẽ không được execute ngay, Khi JS engine free khỏi các current code, nó sẽ lấy tasks từ queue và thực hiện nó.
- Để thực hiện đúng thứ tự thì chèn thêm handler như .then.


*** Unhandled rejection :
- Ta sẽ thấy cách mà event unhandledrejection được JS nhận biết.

=> 1 'unhandled rejection' xảy ra khi 1 promise error không được handler at the end of the microtask queue.

- Thông thường nếu ta muốn bắt 1 lỗi ta dùng .catch :

		let promise = Promise.reject(new Error("Promise Failed!"));
		promise.catch(err => alert('caught'));

		// doesn't run: error handled
		window.addEventListener('unhandledrejection', event => alert(event.reason));
		
- Nhưng khi ta quên add .catch , sau đó sau khi microtask queue trống thì engine sẽ kích event :

	let promise = Promise.reject(new Error("Promise Failed!"));

	// Promise Failed!
	window.addEventListener('unhandledrejection', event => alert(event.reason));
	
- 